Notes to self on vive tutorial extensions:

Unity joints:

Why do we use joints? -> They're Unity's built in feature for making the motion of
one object depend on another. You could do this with transforms or parenting, but this
is better because:
1. it's safer (in terms of coding best practices). Parenting could result in functions
getting called on the child by mistake, and potentially result in desync between the 
client and the server.
2. it is part of Unity's physics engine, so 'plays nice' with other physical interactions.
	
	Started by making some things to pick up:
		- Balls in Unity
			- Needs a transform nature
			- Needs a rigidbody
			- Scale and colour to taste
		- Ball Nature
		- Ball spawner worldapp
		- Launch config to start worldapp
		
	Check that we're doing collision correctly:
		- Make hands light up on collision (indicate hit)
			- Add a collider to each hand (in this case I just use a sphere collider on the spheres that make up the hand)
			- Make the colliders triggers (tick the 'IsTrigger') box
			- Make two materials for the hands: one for touching and one for not touching
			- Put the not touching one on the hands for now
			- Add a script to the hand GrabItemsBehaviour
				- Public materials that determine touching or not touching (set in editor by drag and drop)
				- Public renderer to change (drag hand model in)
				- OnTriggerEnter/Exit routines to change the colour
			
	Listen to the collision:
		- Expose the gameobject of whatever we're colliding with
		- In InputSender
			- Listen for trigger pull
			- Get the relevant gameobject's entityId
			- Add PickUpEvent and DropEvent to schema and run codegen
			
			
			
		- Listen for trigger pull on controller
			- Add a public SteamVR_TrackedObject to the GrabItemsBehaviour
			- Drag on the corresponding controller for each hand in the editor
			- If the trigger is being pulled: provide haptic feedback
		- Make this produce a stateevent
			- The state event holds target entity id and which hand is trying to do the action
			- Send a message to pick up/drop from within InputSender
			- InputReceiver needs to handle receiving this
		- Add Unity Joints to the player hands and connect them up to InputSender/Receiver
			- This will need rigidbody on your hands, set this to 'Is Kinematic = true'
			  and 'Use Gravity = false', so that your hands don't fall away
	
	Test it!
		- Though really this tutorial is done in a way that you could have been checking as you go
		- You should be able to walk around, pick up the balls, move them and drop them
		
	But wait! There's lag
		- This segues really nicely into doing CSP


A note about throwing:
If you try to throw the ball, it will drop straight down. This is because we're
moving it around by fixing it to the transform of the hand. The hand jumps around
according to the controller positions, and doesn't have the concept of a velocity.
If you want to throw the ball, you should set its velocity to release velocity
just after you release it.
This is fixed with the trackpositionbehaviour (code in next tutorial branch).
Alternatively, you could make the implementation of tracking the vive controllers
use the rigidbody moveposition functionality, rather than setting the transform's
position.


Client side authority section:

What are we trying to fix?
In the previous demo, everything was server-side authority.
This means that following an input, you'd have to wait for the
message to be sent to the server, then for the server to process
the physics, then for the result to be sent back.
This is laggy, and the results don't come back at 60fps, so looks
choppy.

How can we resolve this?
Client-side authority.
Whenever a player picks something up to move it, we're going to
delegate the state to the player.

What are the risks?
1 Cheating: any client-side system might falsely report data, and
            this could be exploited by cheaters in the game
2 Weird Physics: things now look laggy from the perspective of 
	        	 the server if a player has high latency

How could we address the risks?
1 Sanity checking inputs: this will depend on your game,
						  and won't be covered here
2 Client-side prediction instead of authority


Making client side authority:

- RequestClientControlBehaviour on the GSIM:
	- Watch the player controls, when there's a pickup event, send a message to the 
	  picked up entity telling it to delegate authority to the client
	- Remember to add this to the player nature
- HandleClientControlBehaviour on the GSIM:
	- Listen to messages. When receive a message for a request for behaviour, give
	  use the transform interface to give authority to the client.
	 - Add this behaviour to the ball


A new problem arises: when do we give authority back?
- If a client disconnects while it had authority over a state, we need to make sure
  that it doesn't just hang in the air
- If a client is no longer interacting with a ball, authority should go back to physics
- What happens if two players try to pick up the same ball?

One nice thing that already happens:
- If a different player grabs the ball, they'll instantly gain authority over it. So
  the last question is a non-issue.


Solution: We add some code to make a 'heartbeat':
- In Schema:
	- Add a new state event to player controls: grabbingheartbeat
- In Unity:
	- Every second that an entity is being held, make a state event
	  to confirm this (use coroutine)
- In GSim:
	- The player controls handling passes on a message to the ball
	- In HandleClientControlBehaviour, if we haven't received one of
	  these messages within the last few seconds, reassign authority
	   --> do this by scheduling messages to ourselves, a little involved